#!/bin/bash

[ -f $(dirname $0)/bash-wrapper-functions ] && . $(dirname $0)/bash-wrapper-functions || { echo "[error]: $(dirname $0)/bash-wrapper-functions not found, the application was probably not installed correctly" 1>&2; exit 1; }

MAIN_CLASS=io.novaordis.tda.Main
JAVA_DEBUG_ARGS="-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005"
VERBOSE=false

function main() {

    #
    # loop over command line arguments and handle common arguments
    #

    local args
    local command
    local java_debug_args

    while [ -n "$1" ]; do

        debug "arg: $1"

        if [ "$1" = "-d" -o "$1" = "--debug" ]; then

            java_debug_args="${JAVA_DEBUG_ARGS}"

        elif [ "$1" = "-v" -o "$1" = "--verbose" ]; then

            VERBOSE=true

        elif [ "$1" != "${1/ //}" ]; then

            #
            # the argument contains spaces, which means double quote were used. We need to pass those down, so the
            # java command line parsing logic can detect the quoted strings. More then that, if the double quoted
            # string contains escaped quotes, we want to pass them as such
            #
            # TODO: if more than one space is enclosed in quotes, the block of spaces is not passed, it is converted
            #       to just one space, which is a defect. Fix.
            #
            escaped_inner_quotes=${1//\"/\\\"}
            args="${args} \"${escaped_inner_quotes}\""

        elif [ -z "${command}" ]; then

            command=$1

        else

            args="${args} $1"
        fi
        shift
    done

    debug "command: ${command}"


    if [ "${command}" = "version" ]; then

        #
        # "version" handling - "light" version retrieval
        #

        debug "handling version"

        local version=$(get-version)
        if [ -n "${version}" ]; then

            #
            # display and exit
            #
            echo "${version}"
            return 0
        fi

        #
        # we weren't able to handle it satisfactory at the bash level, pass it to the java runtime at the front of
        # the argument list
        #
        args="${command} ${args}"

    else

        #
        # the command is not handled in bash, add it to the front of the argument list
        #

        args="${command} ${args}"
    fi



    local java_bin
    java_bin=$(get-java-binary) || exit 1

    debug "java_bin: ${java_bin}"

    local classpath
    classpath=$(get-classpath-from-directory $(dirname $0)/../lib true)

    debug "classpath: ${classpath}"

    debug "arguments:>${args}<"

    ${java_bin} ${java_debug_args} -cp ${classpath} ${MAIN_CLASS} ${args}
}

main "$@"
