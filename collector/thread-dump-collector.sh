#!/bin/bash

#
# see help() below
#
VERSION=6

#
# configuration
#

#
# the directory to write thread dumps into. If it does not exist, it will be created; the default
# behavior if not specified is to create a dated sub-directory in the current directory every
# time the script is executed. Overridden by the command line argument --dir=...
#
dir=

#
# the interval (in seconds) between successive readings
#
interval=30

#
# regular expression used to select the java process we want to take thread dumps of. Overridden by
# command line argument --regex=...
#
regex="java.*D.Standalone"

#
# java_home to use. If set here, will override the JAVA_HOME environment variable, if present, but
# it will be overridden by --java-home= command line argument, if present.
#
java_home=

#
# A "fail-fast" protection for the case collection has to be done with a specific Unix user. If
# this variable is configured, and the Unix user executing the script does not match the value,
# the collector will fail quickly with an explanatory message, instead of waiting until jstack
# cannot access the remote java process and fails with a more obscure message
#

user=jboss

VERBOSE=false


function help() {

cat <<EOF

A script that invokes jstack and top periodically on the java process selected by a regular
expression applied to the process list. Thread dump outputs and top outputs are collected in
two different files, created in the specified target directory. If the target java process
is restarted and its PID changes, new files whose name reflect the PID change will be created,
but otherwise results of successive readings will accumulate in the same files. The script
expects to find  JAVA_HOME set to the correct value, and it will used JAVA_HOME to locate
the jstack binary in \$JAVA_HOME/bin. However, the script can be configured to use a custom
Java home directory by using command line argument --java-home=.

A failure to take a thread dump on the Java process does not interrupt the main loop. Failure
details are logged in the thread dump and log files instead. For this reason, it is best if
the log and thread dump file content is checked before launching this program in background
and leaving it unattended.

The collector script will detach from the controlling terminal and execute in background. All
logging information generated by the script while executing in background will be redirected
and appended to a log file created in the same directory as the data files. Successive collector
executions will keep appending to the log, and previous log information will not be discarded.

Usage:

    ./thread-dump-collector.sh
        [--dir=<target-directory>] [--regex=...] [--interval=<secs>] [--java-home=...]
        start|status|stop|pid

where:

    --dir=<target-directory> specifies the directory to write the thread dump files into.
      If the directory does not exist, it will be created. If the configuration option is
      not explicitly specified, the default behavior is to create a dated sub-directory in
      the current directory every time the script is executed.

    --regex="<regex>" specifies a grep regular expression that will be used to select java
      process we want to take thread dumps of. Example:

            java.*myjar\.jar

    --interval=<interval-in-secs> the interval between successive readings, in seconds.
      The default value is 30 seconds.

    --java-home=<java-home-directory> a directory to be used as JAVA_HOME, thus ignoring the
      value of JAVA_HOME, if exists.

    -v, --verbose the script will generate debug logging.

All configuration parameters specified described are also declared in the script itself and
have the defaults mentioned in their description. If a configuration parameter is declared
on command line, that value takes precedence over the one declared in the script.

Auxiliary commands:

    help - this help

    pid - displays the PID that will be used by jstack after applying the regular expression
        on the process list. Useful to test the regular expression.

EOF
}

function debug() {

    ${VERBOSE} && echo "$@" 1>&2;
}

#
# If a valid PID is selected by the regex, it is sent to stdout and the function returns 0.
# If no Java PID can be detected, or upon any other kind of external failure, return 1.
# Exits on invalid argument.
#
function get-java-pid() {

    local regex="$1"
    [ -z "${regex}" ] && { echo "get-java-pid(): regex not provided" 1>&2; exit 1; }

    local failure=false

    java_pid=$(ps -ef | grep "${regex}" | grep -v grep | grep -v $0 | awk '{print $2}') || failure=true

    if [ -z "${java_pid}" ]; then

        debug "get-java-pid(): regular expression '${regex}' did not select any process"
        failure=true
    fi

    java_pid="$(echo ${java_pid})"

    if [ "${java_pid// /}" != "${java_pid}" ]; then

        echo "[warn]: regular expression '${regex}' selected more than one process: ${java_pid}" 1>&2
        failure=true
    fi

    if ${failure}; then
        return 1
    else
        echo ${java_pid}
        return 0
    fi
}

#
# return at stdout the pid of the unique collector running in background on the system or the empty string if no such
# collector is identified
#
function get-collector-pid() {

    IFS="$(printf '\n\r')"

    for proc_details in $(ps -ef | grep $(basename $0) | grep -v grep); do

        debug "collector process details: ${proc_details}"

        local collector_pid
        local parent_pid

        collector_pid=$(echo "${proc_details}" | awk '{print $2}') || exit 1
        parent_pid=$(echo "${proc_details}" | awk '{print $3}') || exit 1

        debug "collector_pid: ${collector_pid}, parent_pid: ${parent_pid}"

        if [ "${parent_pid}" = "1" ]; then
            echo "${collector_pid}"
            break;
        fi
    done
    IFS="$(printf ' \t\n')"
}
function create-directory-if-does-not-exist() {

    local dir=$1

    if [ "${dir}" = "" ]; then
        dir="./"$(date +'%y.%m.%d-%H.%M.%S')"-thread-dumps"
    fi

    if [ ! -d ${dir} ]; then
        echo "creating ${dir} ..." 1>&2
        mkdir -p ${dir} || exit 1
    fi

    echo "${dir}"
}

#
# the function MUST not exit, as we want to run it in a loop. However, it should return 0 on success or non-zero on
# failure. If the collection commands fail, the jstack-and-top-snapshot() execution will be considered a success,
# but the failure output will also be redirected in the data files.
#
function jstack-and-top-snapshot() {

    debug "executing jstack-and-top-snapshot()"

    local pid=$1
    local output_filename_prefix=$2
    local output_dir=$3
    local java_home=$4

    [ -z "${pid}" ] && { echo "jstack-and-top-snapshot(): pid not provided" 1>&2; return 1; }
    [ -z "${output_filename_prefix}" ] && { echo "jstack-and-top-snapshot(): output_filename_prefix not provided" 1>&2; return 1; }
    [ -z "${output_dir}" ] && { echo "jstack-and-top-snapshot(): output_dir not provided" 1>&2; return 1; }
    [ -d ${output_dir} ] || { echo "jstack-and-top-snapshot(): output_dir ${output_dir} not a valid directory" 1>&2; return 1; }
    [ -z "${java_home}" ] && { echo "jstack-and-top-snapshot(): java_home not provided" 1>&2; return 1; }

    local timestamp=$(date)

    local thread_dump_file_name="${output_filename_prefix}-jstack.out"
    local top_output_file_name="${output_filename_prefix}-top.out"

    echo "${timestamp}" >> ${output_dir}/${thread_dump_file_name}

    debug "executing ${java_home}/bin/jstack -l ${pid} 2>&1 >> ${output_dir}/${thread_dump_file_name}"

    local residual_output
    residual_output=$(${java_home}/bin/jstack -l ${pid} 2>&1 >> ${output_dir}/${thread_dump_file_name})
    [ -n "${residual_output}" ] && echo "${residual_output}" >>  ${output_dir}/${thread_dump_file_name}

    echo "${timestamp}" >> ${output_dir}/${top_output_file_name}
    residual_output=$(top -b -n 1 -H -p ${pid} 2>&1 >> ${output_dir}/${top_output_file_name})
    [ -n "${residual_output}" ] && echo "${residual_output}" >>  ${output_dir}/${top_output_file_name}

    return 0
}

#
# the main loop; may execute in background or foreground (not really useful)
#
function loop() {

    local current_pid
    local output_filename_prefix
    first=true

    while [ true ]; do

        local pid

        pid=$(get-java-pid "${regex}")

        debug "loop(): current pid: ${current_pid}, java pid: ${pid}"

        if [ -z "${pid}" ]; then

            #
            # we weren't able to get a java pid from the configured regular expression, that may mean the
            # JVM is being bounced, so keep looping until we are explicitly stopped; however, do not erase
            # the current PID, we've seen situations when we were able to re-use it after a while
            #

            echo "$(date): failed to select java process for regex \"${regex}\""
            sleep ${interval}
            continue;
        fi

        #
        # we have what is seems to be a valid PID
        #

        if [ "${current_pid}" != "${pid}" ]; then
            current_pid=${pid}
            output_filename_prefix=$(date +'%y.%m.%d-%H.%M')-${current_pid}
            debug "file name initialized to ${output_filename_prefix}..."
        fi

        jstack-and-top-snapshot "${current_pid}" "${output_filename_prefix}" "${dir}" "${java_home}"

        if ${first}; then
            echo "$(date): collecting thread dumps in ${dir}, interval ${interval} seconds "
            first=false
        fi

        echo "$(date): successful jstack reading"
        sleep ${interval}
    done
}

function check-user() {

    local user=$1

    if [ -z "${user}" ]; then

        debug "check-user(): we are not checking the user"
        return 0
    fi

    local current_user
    current_user=$(whoami) || exit 1

    if [ "${user}" != "${current_user}" ]; then
        echo "[error]: the collector must execute as '${user}' but it is executing as '${current_user}'" 1>&2
        return 1
    fi
}

function main() {

    #
    # this is the first time we are being invoked in foreground, process arguments
    #

    local command

    while [ -n "$1" ]; do

        if [ "$1" = "help" -o "$1" = "--help" -o "$1" = "-help" -o "$1" = "-?" ]; then
           command="help"
        elif [[ "$1" =~ --dir= ]]; then
            dir=${1:6}
            [ -z "${dir}" ] && { echo "a value must follow --dir=" 1>&2; exit 1; }
            dir=${dir//\~/${HOME}}
        elif [[ "$1" =~ --regex= ]]; then
            regex=${1:8}
        elif [[ "$1" =~ --interval= ]]; then
            interval=${1:11}
        elif [[ "$1" =~ --java-home= ]]; then
            java_home=${1:12}
        elif [ "$1" = "-v" -o "$1" = "--verbose" ]; then
            VERBOSE=true
        elif [ "$1" = "pid" ]; then
            command="pid"
        elif [ "$1" = "stop" ]; then
            command="stop"
        elif [ "$1" = "start" ]; then
            command="start"
        elif [ "$1" = "status" ]; then
            command="status"
        fi
        shift
    done

    if [ "${command}" = "help" ]; then
        help
        return 0
    elif [ "${command}" = "pid" ]; then
        get-java-pid "${regex}"
        return 0
    fi

    #
    # at this point, check if a copy of ourselves is not already executing in background
    #
    local background_collector_pid
    background_collector_pid=$(get-collector-pid) || exit 1

    if [ "${command}" = "status" ]; then

        if [ -n "${background_collector_pid}" ]; then
            echo "$(basename $0) is running in background with pid ${background_collector_pid}"
        else
            echo "$(basename $0) is not running in background"
        fi
        return 0
    fi

    if [ "${command}" = "stop" ]; then

        if [ -n "${background_collector_pid}" ]; then
            kill -9 ${background_collector_pid} && echo "successfully stopped $(basename $0)" || exit 1
        else
            echo "$(basename $0) is not running in background";
        fi
        return 0
    fi

    if [ -n "${background_collector_pid}" ]; then

        echo "$(basename $0) is already running in background with pid ${background_collector_pid}" 1>&2;
        exit 1;
    fi

    #
    # verify we are running with the correct user
    #
    check-user ${user} || exit 1

    dir=$(create-directory-if-does-not-exist "${dir}") || exit 1

    debug "$(basename $0) is using directory ${dir} to write data and logs"

    local log_file=${dir}/$(basename $0)
    log_file=${log_file%.sh}
    log_file=${log_file}.log

    debug "$(basename $0) will write logs into ${log_file}"

    [ -z "${java_home}" ] && java_home=${JAVA_HOME}
    [ -z "${java_home}" ] && { echo "[error]: JAVA_HOME environment variable not set and no --java-home= command line argument was used" 1>&2; exit 1; }
    [ -x ${java_home}/bin/jstack ] || { echo "[error]: ${java_home}/bin/jstack does not exist or it is not an executable file" 1>&2; exit 1; }

    debug "$(basename $0) using java_home: ${java_home}"

    debug "sending ourselves in the background while writing to log ${log_file}"

    loop >> ${log_file} 2>&1 &

    debug "a copy of ourselves is executing in background, so now we are now exiting ..."

}

main $@

