package io.novaordis.events.tdp;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.text.Format;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

/**
 * An individual thread dump, containing the snapshots of all threads in the JVM at a certain moment
 * in time. A log file (or a stdout dump file) may contain multiple thread dumps, so it may have
 * associated multiple ThreadDump instances.
 *
 * @see ThreadDumpFile
 *
 * @author <a href="mailto:ovidiu@novaordis.com">Ovidiu Feodorov</a>
 *
 * Copyright 2010 Ovidiu Feodorov
 */
public class ThreadDump {

    // Constants -------------------------------------------------------------------------------------------------------

    public static final Format HEADER_TIMESTAMP_FORMAT = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    // Static ----------------------------------------------------------------------------------------------------------

    // Attributes ------------------------------------------------------------------------------------------------------

    private File file;

    private Date timestamp;
    private String header;
    private long headerLineNumber;
    private List<StackTrace> stackTraces;

    private StackTrace current;

    private boolean closed;

    // Constructors ----------------------------------------------------------------------------------------------------

    /**
     * @param timestamp - the timestamp to associate the thread dump with, if the VM did not
     *        capture it at the time of the dump. May be null.
     */
    ThreadDump(File file, Date timestamp, String header, long headerLineNumber) {

        this.file = file;
        this.timestamp = timestamp;
        this.header = header;
        this.headerLineNumber = headerLineNumber;
        this.stackTraces = new ArrayList<>();
        this.current = new StackTrace();
        this.closed = false;
    }

    // Public ----------------------------------------------------------------------------------------------------------

    /**
     * May be null if we did not get the proper timestamp in the snapshot.
     */
    public Date getTimestamp() {

        return timestamp;
    }

    public String getHeader() {

        return header;
    }

    public long getHeaderLineNumber() {

        return headerLineNumber;
    }

    public int getThreadCount() {

        return stackTraces.size();
    }

    public Iterator<StackTrace> iterator() {

        return stackTraces.iterator();
    }

    /**
     * @return the name of the thread with the given tid, or null if there is no such thread.
     */
    public String getName(long tid) {

        for(StackTrace st: stackTraces) {

            Long stTid = st.getTid();

            if (stTid == null) {

                continue;
            }

            if (stTid == tid) {

                return st.getName();
            }
        }

        return null;
    }

    public File getFile() {

        return file;
    }

    public void toFile(File target) throws Exception {

        BufferedWriter bw = null;

        try {

            bw = new BufferedWriter(new FileWriter(target));

            //
            // write the original header + "(generated by tdp)"
            //

            if (getTimestamp() != null) {
                bw.write(HEADER_TIMESTAMP_FORMAT.format(getTimestamp()) + "\n");
            }

            bw.write(getHeader() + " (generated by tdp)\n\n");

            for(Iterator<StackTrace> i = iterator(); i.hasNext(); ) {

                StackTrace td = i.next();

                bw.write(td.getOriginal());

                bw.write("\n");
            }
        }
        finally {

            if (bw != null) {

                bw.close();
            }
        }
    }

    @Override
    public String toString() {

        return
            "[" +
            (timestamp == null ? "UNDATED" : ThreadDumpFile.TIMESTAMP_FORMAT.format(timestamp)) + ", " +
            getThreadCount() + " threads" +
            "]";
    }

    // Package protected -----------------------------------------------------------------------------------------------

    // Protected -------------------------------------------------------------------------------------------------------

    void append(String line, long lineNumber)  {

        if (closed) {

            throw new IllegalStateException(this + " is closed, no more lines can be appended to it");
        }

        if (line.trim().length() == 0) {

            // empty line - cue to start a new StackTrace

            if (current.isValid()) {

                //
                // add the last StackTrace to the collection
                //
                stackTraces.add(current);
                current = new StackTrace();
            }
            else {

                //
                // clean the garbage accumulated so far
                //
                current.clear();
            }
        }
        else {

            current.append(line, lineNumber);
        }
    }

    /**
     * "closes" this thread dump - it is the notification that no more lines will be appended.
     */
    void close() {

        if (current.isValid()) {

            // save the latest one
            stackTraces.add(current);
        }

        current = null;
        closed = true;
    }

    // Private ---------------------------------------------------------------------------------------------------------

    // Inner classes ---------------------------------------------------------------------------------------------------
}
